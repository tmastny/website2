---
title: 'Visualizing CPU Pipelining'
author: ~
date: '2024-11-30'
slug: visualizing-cpu-pipeling
categories: []
tags: []
description: 'Visualizing CPU Pipelining'
output:
  blogdown::html_page:
    toc: true
---


<div id="TOC">
<ul>
<li><a href="#instruction-decoding" id="toc-instruction-decoding">Instruction Decoding</a></li>
<li><a href="#hazard-detection-unit" id="toc-hazard-detection-unit">Hazard detection unit</a></li>
</ul>
</div>

<p>I want to share I’ve learned about CPU pipelining.
Thanks to Dan Luu’s branch <a href="https://danluu.com/branch-prediction/">prediction write-up</a>
I was vaguely aware how this worked conceptually,
but I was motivated to divide into the details after reading
Rodrigo Copetti’s <a href="https://www.copetti.org/writings/consoles/playstation/#bibref:9">Playstation MIPS write-up</a>
where he talked the need for
branch delay slots and how later CPUs used this to as an advantage
with branch <em>prediction</em>. I quickly found many subtle and
fasincating details on CPU pipelining that I had to share.
For more details, I recommend
chapter 4 of Computer Organization and Design.</p>
<p>This post will assume you are familiar with the <a href="https://www.cybercomputing.co.uk/Languages/Hardware/laundryAnalogy.html">laundry</a>
or “assembly-line” model of CPU pipelining, but are hazy on some of the
lower-level details. It will also help to have a vague idea of
the 5-stage MIPS pipeline.</p>
<p>Let’s start by visualizing a basic CPU model that does not have pipelining
(aka a single-cycle CPU design):</p>
<div id="nonpipeline-container"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const container = document.getElementById('nonpipeline-container');
  container.innerHTML = createPipelineHTML('nonpipelineViz');
  
  window.nonpipelineViz = new PipelineVisualization(
    document.getElementById('nonpipelineViz'),
    {
      instructions: [
        "add $t1",
        "sub $t2",
      ],
      sequence: [
        { pc: 0 },
        { pc: 1, if: "add $t1" },
        { pc: 1, id: "add $t1" },
        { pc: 1, ex: "add $t1" },
        { pc: 1, mem: "add $t1" },
        { pc: 1, wb: "add $t1" },
        { pc: 2, if: "sub $t2" },
        { pc: 2, id: "sub $t2" },
        { pc: 2, ex: "sub $t2" },
        { pc: 2, mem: "sub $t2" },
        { pc: 2, wb: "sub $t2" },
        { pc: null }
      ]
    }
  );
});
</script>
<p>One bottleneck is that each individual component of the pipeline
is inactive while the instruction is actively being processed in
another stage.</p>
<p>Pipelined CPUs fill in these vacancies by running instructions
through the stages one after the other, rather than waiting
for a single instruction to finish.</p>
<style>
/* Your existing CSS stays the same */
.pipeline-viz {
  font-family: monospace;
  margin: 2em 0;
  padding: 2em;
  width: 800px;
  overflow-x: auto;
}

.controls {
  margin-bottom: 1em;
}

.control-button {
  padding: 0.5em 1em;
  margin-right: 0.5em;
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  cursor: pointer;
  font-family: monospace;
}

.control-button:hover {
  background: #e9ecef;
}

.instructions-list {
  margin-bottom: 2em;
}

.instruction {
  padding: 0.5em;
  margin: 0.25em 0;
  background: #f8f9fa;
  border-radius: 4px;
  opacity: 0.7;
}

.instruction.active {
  background: #e6f3ff;
  opacity: 1;
  font-weight: bold;
}

.pipeline {
  display: flex;
  justify-content: flex-start;
  gap: 1em;
  margin-top: 2em;
}

.stage-container {
  flex: 1;
  text-align: center;
}

.stage-name {
  margin-bottom: 0.5em;
  font-weight: bold;
}

.stage {
  height: 60px;
  width: 140px;
  padding: 0.5em;
  border-radius: 4px;
  border: 1px solid #dee2e6;
  background: #ffffff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.9em;
}

.stage.active {
  background: #f8f9fa;
  border-color: #adb5bd;
}
</style>

<script>
// Fixed createPipelineHTML function with correct button handlers
function createPipelineHTML(id) {
  return `
    <div class="pipeline-viz" id="${id}">
      <div class="controls">
        <button onclick="window.${id}.stepBack()" class="control-button">◀ Previous</button>
        <button onclick="window.${id}.stepForward()" class="control-button">Next ▶</button>
        <button onclick="window.${id}.reset()" class="control-button">Reset</button>
      </div>
      
      <div class="instructions-list">
        <div id="${id}-instructions"></div>
      </div>
      
      <div class="pipeline">
        <div class="stage-container">
          <div class="stage-name">IF</div>
          <div class="stage" data-stage="if"></div>
        </div>
        <div class="stage-container">
          <div class="stage-name">ID</div>
          <div class="stage" data-stage="id"></div>
        </div>
        <div class="stage-container">
          <div class="stage-name">EX</div>
          <div class="stage" data-stage="ex"></div>
        </div>
        <div class="stage-container">
          <div class="stage-name">MEM</div>
          <div class="stage" data-stage="mem"></div>
        </div>
        <div class="stage-container">
          <div class="stage-name">WB</div>
          <div class="stage" data-stage="wb"></div>
        </div>
      </div>
    </div>
  `;
}

// Your existing PipelineVisualization class stays exactly the same
class PipelineVisualization {
  constructor(container, config) {
    this.container = container;
    this.config = config;
    this.currentStep = 0;
    this.initialize();
  }

  initialize() {
    const instructionContainer = this.container.querySelector('[id$="-instructions"]');
    this.config.instructions.forEach(inst => {
      const div = document.createElement('div');
      div.className = 'instruction';
      div.textContent = inst;
      instructionContainer.appendChild(div);
    });
    this.render();
  }

  render() {
    const stages = this.container.querySelectorAll('.stage');
    const instructions = this.container.querySelectorAll('.instruction');
    
    stages.forEach(stage => {
      stage.textContent = '';
      stage.classList.remove('active');
    });
    
    instructions.forEach(inst => inst.classList.remove('active'));

    const state = this.config.sequence[this.currentStep] || {};
    
    Object.entries(state).forEach(([stage, instruction]) => {
      if (instruction && stage !== 'pc') {
        const stageElement = this.container.querySelector(
          `.stage[data-stage="${stage.toLowerCase()}"]`
        );
        if (stageElement) {
          stageElement.textContent = instruction;
          stageElement.classList.add('active');
        }
      }
    });

    if (state.pc !== null && state.pc !== undefined && state.pc < instructions.length) {
      instructions[state.pc].classList.add('active');
    }
  }

  stepForward() {
    if (this.currentStep < this.config.sequence.length - 1) {
      this.currentStep++;
      this.render();
    }
  }

  stepBack() {
    if (this.currentStep > 0) {
      this.currentStep--;
      this.render();
    }
  }

  reset() {
    this.currentStep = 0;
    this.render();
  }
}
</script>

<div id="pipeline1-container"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const container = document.getElementById('pipeline1-container');
  container.innerHTML = createPipelineHTML('pipelineViz1');
  
  window.pipelineViz1 = new PipelineVisualization(
    document.getElementById('pipelineViz1'),
    {
      instructions: [
        "add $t1",
        "sub $t2",
        "lw $t3",
        "add $t5",
        "and $t4"
      ],
      sequence: [
        { pc: 0 },
        { pc: 1, if: "add $t1" },
        { pc: 2, if: "sub $t2", id: "add $t1" },
        { pc: 3, if: "lw $t3", id: "sub $t2", ex: "add $t1" },
        { pc: 4, if: "add $t5", id: "lw $t3", ex: "sub $t2", mem: "add $t1" },
        { pc: null, if: "and $t4", id: "add $t5", ex: "lw $t3", mem: "sub $t2", wb: "add $t1" },
        { pc: null, id: "and $t4", ex: "add $t5", mem: "lw $t3", wb: "sub $t2" },
        { pc: null, ex: "and $t4", mem: "add $t5", wb: "lw $t3" },
        { pc: null, mem: "and $t4", wb: "add $t5" },
        { pc: null, wb: "and $t4" },
        { pc: null }
      ]
    }
  );
});
</script>
<p>This seems pretty natural: it’s like an multiple person assembly line.
But there are some subtle implementation details
that sets the stage to solve more complicated problems.</p>
<div id="instruction-decoding" class="section level2">
<h2>Instruction Decoding</h2>
<p>Instruction decoding orchestrates the entire pipeline
by providing reference fields used the remaining stages.</p>
<p>Let’s work through an example. Say the instruction is</p>
<pre><code>add $t1, $s2, $s3</code></pre>
<p>The IF stage fetches the instruction and puts it into
the ID stage register. Now the ID register contains
fields that will be used by all the remaining stages.</p>
<pre><code>pc: 0x014b4820
-&gt; 
Field   op      rs      rt      rd      shamt   funct
Binary  000000  01010   01011   01001   00000   100000
#       add     $s2     $s3     $t1</code></pre>
<ul>
<li>EX will use <code>op</code>, <code>rs</code>, and <code>rt</code> for the ALU
operation and inputs</li>
<li>MEM (for <code>lw</code> and <code>sw</code>) uses <code>rt</code></li>
<li>WB will write to register <code>rd</code></li>
</ul>
<p><img src="id-dep.svg" /><!-- --></p>
<p>With pipelining, we have a problem.
Look at cycle 3 above: <code>add</code> moves into EX and <code>sub</code> moves into ID.
But WB needs to know the <code>rd</code> of the <code>add</code> instruction!
That field used to be safely in the ID register, but <code>sub</code> overwrote it.</p>
<p>The solution is to have registers between each pipeline stage
that carry fields from the ID stage (and data from other stages).</p>
<p><img src="pipeline-registers.svg" /><!-- --></p>
<p>Now when <code>add</code> reaches WB, it has the <code>rd</code> field so it
can write to the correct register!</p>
</div>
<div id="hazard-detection-unit" class="section level2">
<h2>Hazard detection unit</h2>
<div id="pipeline2-container"></div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const container = document.getElementById('pipeline2-container');
  container.innerHTML = createPipelineHTML('pipelineViz2');
  
  window.pipelineViz2 = new PipelineVisualization(
    document.getElementById('pipelineViz2'),
    {
      instructions: [
        "add r3, r1, r4",
        "sub r5, r3, r6"
      ],
      sequence: [
        { pc: 0 },
        { pc: 1, if: "add r3, r1, r4" },
        { pc: 2, if: "sub r5, r3, r6", id: "add r3, r1, r4" },
        { pc: null, id: "sub r5, r3, r6", ex: "add r3, r1, r4" },
        { pc: null, id: "sub r5, r3, r6", mem: "add r3, r1, r4" },
        { pc: null, id: "sub r5, r3, r6", wb: "add r3, r1, r4" },
        { pc: null, ex: "sub r5, r3, r6" },
        { pc: null, mem: "sub r5, r3, r6" },
        { pc: null, wb: "sub r5, r3, r6" },
        { pc: null }
      ]
    }
  );
});
</script>
</div>
