---
title: Algorithmic Complexity in Hardware
author: ~
date: '2021-07-02'
slug: algorithmic-complexity-hardware
categories: []
tags: []
output:
  blogdown::html_page:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, warning=FALSE, message=FALSE,
  results='show', cache=FALSE, autodep=FALSE, error = TRUE
)
```

> Note: This is a 
  part of a series of articles for my package tsrecipes
  ([Github](https://github.com/tmastny/tsrecipes), 
  [website](https://tmastny.github.io/tsrecipes/)).
  The full article, including the code, can be found
  [here](https://tmastny.github.io/tsrecipes/articles/dct.html). 

---

algorithmic-complexity-of-carry-lookahead-adders
## Introduction

Problem: how do we take to the logical `AND` of `n` bits?
- sequential: O(n)
- divide and conquer: O(log n)

What does this look like in hardware?

In the algorithmic analysis of software, we are concerned with
time and memory complexity. 

Hardware introduces a new component: space (or cost) complexity.

Could build an array of `AND` gates with a height of O(log n). 
But the number of gates would be O(2^n). 



Why would we ever want to build a gate like that? Isn't there a way
we can reuse gates like in software? There is, but this does have 
an application in carry-lookahead adders.

Before we explain, what is the time complexity of adding two `n`-bit numbers?
In sequential software, we can only look at one bit at a time and we have to 
look at each one to add the number.

Hardware on the other hand has some inherent parallelism. Each bit is stored
on a lead, and those leads can be connected to a logic gate. 
But to implement adding, we have to calculate the carry bit. 
That's a sequential operation. 

But it's only sequential if our space complexity is O(n). If we increase,
the space used, we can add two numbers much faster.


Example how carry-ahead works.


Now we return to our parallel `AND` circuit. Because the height is O(log n),
that's also the time complexity of of adding two `n`-bit numbers. 
But the trade-off is O(2^n) space, which is unmanageably large relatively small
`n`.

Therefore, carry-lookahead adders are usually implemented on 4-bits, and
are chained together in such a way that the time complexity is still O(n),
but with a constant factor speedup. 